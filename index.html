<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trust Payments Google Pay Test</title>
  <link rel="icon" href="data:," />
  <style>
    body { font-family: system-ui, sans-serif; padding: 20px; max-width: 1200px; margin: 0 auto; }
    #st-google-pay { width: 100%; max-width: 400px; height: 60px; margin: 20px 0; border: 1px dashed #ccc; }
    #payment-result { display: none; white-space: pre-wrap; background: #f8fafc; border: 1px solid #cbd5e1; border-radius: 6px; padding: 10px; max-width: 900px; }
    .error { color: #dc2626; }
    .success { color: #16a34a; }
  </style>
</head>

<body>
  <h1>Google Pay Test</h1>
  <div id="st-notification-frame"></div>
  <form id="st-form"></form>
  <div id="st-google-pay"></div>
  <p id="status">Initializing...</p>
  <pre id="payment-result"></pre>

  <script src="./config.js"></script>
  <script src="https://cdn.eu.trustpayments.com/js/latest/st.js"></script>
  <script>
    (async function() {
      // Configuration
      const TEST_AUTH_TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTg3MzdiZDgtZmIxNC00ODVlLWFlNWUtMjVlYzBhMWY1OWFjIiwiZW1haWwiOiJtdXNodGFxYWxpbWFsaWsxMUBnbWFpbC5jb20iLCJpYXQiOjE3NzIwMjA5MDIsImV4cCI6MTc3MjEwNzMwMn0.PzLJxhVJDoFrLyxArEuTmEIDWlbDXY1xe1iB-_kQh0s";
      
      const statusEl = document.getElementById('status');
      const notificationFrame = document.getElementById('st-notification-frame');
      const resultEl = document.getElementById('payment-result');
      
      const API_BASE_URL = (window.PAYMENT_API_BASE_URL || '').replace(/\/$/, '');
      const api = (path) => `${API_BASE_URL}${path}`;

      let paymentSessionId = localStorage.getItem('paymentSessionId');

      function decodeJwtPayload(token) {
        try {
          const base64Url = token.split('.')[1];
          const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
          const padded = base64.padEnd(Math.ceil(base64.length / 4) * 4, '=');
          return JSON.parse(atob(padded));
        } catch {
          return null;
        }
      }

      function showOutcome(success, message, details = {}) {
        statusEl.textContent = message;
        statusEl.className = success ? 'success' : 'error';
        
        if (Object.keys(details).length > 0) {
          resultEl.style.display = 'block';
          resultEl.textContent = JSON.stringify(details, null, 2);
        }

        console.log(success ? 'âœ… SUCCESS' : 'âŒ FAILED', { message, details });
        
        // Show alert for immediate feedback (like old code)
        alert(success ? 'Payment Successful' : 'Payment Failed: ' + message);
      }

      function formatErrorMessage(error) {
        if (!error) return 'Unknown error';
        if (typeof error === 'string') return error;
        if (error.message) return error.message;
        if (error.errorcode || error.errormessage) {
          let text = error.errormessage || 'Payment request failed';
          if (error.errorcode) text += ` (code: ${error.errorcode})`;
          if (error.errordata?.length) text += ` - field: ${error.errordata.filter(Boolean).join(', ')}`;
          return text;
        }
        try {
          return JSON.stringify(error);
        } catch {
          return 'Unknown error';
        }
      }

      // Handle gateway response from redirect
      async function handleGatewayResponse() {
        const query = new URLSearchParams(window.location.search);
        const responseJwt = query.get('jwt');
        const errorcode = query.get('errorcode');
        const transactionreference = query.get('transactionreference');

        if (!responseJwt && !errorcode && !transactionreference) return;

        const basicResult = {
          errorcode,
          transactionreference,
          errormessage: query.get('errormessage'),
          enrolled: query.get('enrolled'),
          settlestatus: query.get('settlestatus')
        };

        if (responseJwt && paymentSessionId) {
          try {
            console.log('ðŸ” Verifying payment with backend...');
            
            const verifyRes = await fetch(api('/api/v1/payments/response/verify'), {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ 
                jwt: responseJwt,
                paymentSessionId 
              })
            });

            const verifiedPayload = await verifyRes.json();

            if (!verifyRes.ok || !verifiedPayload.verified) {
              throw new Error(verifiedPayload.error || 'Verification failed');
            }

            const gatewayResponse = verifiedPayload.gatewayResponse || {};
            const approved = gatewayResponse.errorcode === '0' || errorcode === '0';
            
            showOutcome(approved, 
              approved ? 'Payment successful' : 'Payment failed', 
              { summary: basicResult, gatewayResponse }
            );

            if (approved) {
              localStorage.removeItem('paymentSessionId');
            }

          } catch (error) {
            // Try to decode JWT client-side as fallback (like old code)
            const decodedClientSide = decodeJwtPayload(responseJwt);
            showOutcome(false, 'Verification failed: ' + error.message, { 
              summary: basicResult,
              decodedPayload: decodedClientSide,
              error: error.message 
            });
          }
        } else {
          const approved = errorcode === '0';
          showOutcome(approved, 
            approved ? 'Payment successful' : 'Payment failed. Code: ' + errorcode,
            basicResult
          );
        }

        window.history.replaceState({}, document.title, window.location.pathname);
      }

      // Error handlers
      window.addEventListener('error', (event) => {
        showOutcome(false, 'Error: ' + formatErrorMessage(event.error || event.message), 
          { source: 'window.error' });
      });

      window.addEventListener('unhandledrejection', (event) => {
        showOutcome(false, 'Error: ' + formatErrorMessage(event.reason), 
          { source: 'unhandledrejection' });
      });

      // Monitor ST notifications
      if (notificationFrame) {
        new MutationObserver(() => {
          const text = notificationFrame.textContent?.trim();
          if (text) {
            console.log('ðŸ“¢ ST Notification:', text);
            statusEl.textContent = 'ST Notification: ' + text;
          }
        }).observe(notificationFrame, { 
          childList: true, 
          subtree: true, 
          characterData: true 
        });
      }

      if (!API_BASE_URL) {
        statusEl.textContent = 'âŒ Set window.PAYMENT_API_BASE_URL in config.js';
        return;
      }

      await handleGatewayResponse();

      try {
        statusEl.textContent = 'â³ Requesting JWT...';
        
        const initRes = await fetch(api('/api/v1/payments/jwt/init'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            amount: '10.00', 
            currency: 'USD',
            authToken: TEST_AUTH_TOKEN
            // Don't send requesttypedescriptions here - it should be in the JWT payload
          })
        });

        if (!initRes.ok) {
          throw new Error(`Init failed with status ${initRes.status}`);
        }

        const { jwt, paymentSessionId: newSessionId } = await initRes.json();
        
        paymentSessionId = newSessionId;
        localStorage.setItem('paymentSessionId', paymentSessionId);
        
        console.log('ðŸ†” Payment Session ID:', paymentSessionId);
        console.log('ðŸ”‘ JWT received');

        statusEl.textContent = 'â³ Initializing Secure Trading...';
        
        const st = SecureTrading({ jwt, errorReporting: true });

        statusEl.textContent = 'â³ Rendering Google Pay button...';

        // FIXED: Match the old working configuration - NO tokenizationSpecification
        const gpayInit = st.GooglePay({
          buttonOptions: {
            buttonRootNode: 'st-google-pay',
            buttonType: 'pay',
            buttonColor: 'black',
            buttonLocale: 'en'
          },
          paymentRequest: {
            environment: 'TEST',
            merchantInfo: {
              merchantId: 'BCR2DN5TZC6I563Y',
              merchantName: 'RRoM International'  // Keep original merchant name
            },
            allowedPaymentMethods: [{
              // Don't include 'type' field - match old working code
              parameters: {
                allowedAuthMethods: ['PAN_ONLY', 'CRYPTOGRAM_3DS'],
                allowedCardNetworks: ['VISA', 'MASTERCARD', 'AMEX']
              }
              // NO tokenizationSpecification - this is handled by ST.js internally
            }],
            transactionInfo: {
              countryCode: 'US',
              currencyCode: 'USD',
              totalPriceStatus: 'FINAL',
              totalPrice: '10.00'
            }
          }
        });

        // Handle promise if returned (like old code)
        if (gpayInit && typeof gpayInit.then === 'function') {
          gpayInit.catch((err) => {
            showOutcome(false, 'Google Pay init error: ' + formatErrorMessage(err), { source: 'GooglePay.init' });
          });
        }

        statusEl.textContent = 'âœ… Google Pay initialized successfully';
        statusEl.className = 'success';

      } catch (error) {
        const errorMessage = formatErrorMessage(error);
        showOutcome(false, 'Initialization failed: ' + errorMessage, { 
          source: 'init',
          error: errorMessage,
          stack: error.stack 
        });
      }
    })();
  </script>
</body>
</html>